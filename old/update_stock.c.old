// update_symbol.c
/* Update of today's (or most recent available) data to stockinfo, stockprices for one symbol
 * Sometimes Yahoo provides bad dates in their data; you can force a correction to the most recent business day 
 * by passing the [force] parm. 
 * This program should normally be run on the same business day, after market close.
 * NOTE: be cautious with "force" as data will be overwritten with no validity checks
 * 
 * Parms: Sym [force]
 * compile: gcc -Wall -O2 -ffast-math -o update_symbol update_symbol.c `mysql_config --include --libs` `curl-config --libs`
 */

// set DEBUG to 1 for testing, 0 for production
#define		DEBUG	0
#define		_XOPEN_SOURCE
#define		_XOPENSOURCE
#define		DAY_SECONDS     3600*24

#include        <my_global.h>
#include        <my_sys.h>
#include        <mysql.h>
#include        <string.h>
#include	<unistd.h>
#include	<curl/curl.h>
#include	<ctype.h>

MYSQL *mysql;
struct	MemStruct {
  char *memory;
  size_t size;
};

#include        "Includes/print_error.inc"

static size_t ParseTicker(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    struct MemStruct *mem = (struct MemStruct *)userp;
    
    mem->memory = realloc(mem->memory, mem->size + realsize + 1);
    if (mem->memory == NULL) {	// out of memory!
      printf("not enough memory to realloc\n");
      exit(EXIT_FAILURE);
    }
    memcpy(&(mem->memory[mem->size]), contents, realsize);
    mem->size += realsize;
    mem->memory[mem->size] = 0;
    return realsize;
}

int main(int argc, char * argv[]) {
  char	qDate[12];
  char	query[1024];
  char	qURL[1024];
  char	Sym[16];
  char	thisDate[16];
  char	buf[1024];
  char	day_open[32]="null";
  char	day_close[32]="null";
  char	day_high[32]="null";
  char	day_low[32]="null";
  char	day_change[32]="null";
  char	volume[32]="null";
  char	prev_close[32]="null";
  char	exchange[32]="null";
  char	capitalisation[32]="null";
  char	low_52weeks[32]="null";
  char	high_52weeks[32]="null";
  char	earnings[32]="null";
  char	dividend[32]="null";
  char	p_e_ratio[32]="null";
  char	avg_volume[32]="null";
  char 	*saveptr;
  char	*saveptr2;
  MYSQL_RES *result;
  MYSQL_ROW row;
  time_t t,t2;
  struct tm *TM = 0;
  struct tm *TM2 = 0;
  int num_rows,x,updated=0,force=0;
  char	errbuf[CURL_ERROR_SIZE];
  CURL *curl;
  CURLcode	res;
  struct	MemStruct chunk;
  
  // parse cli parms
  if (argc == 1 || argc >3) {
    printf("Usage:  %s Sym [force]\n \
    Update the beancounter stockinfo and stockprice with today's data for the given symbol\n \
    Supplying the \"force\" parm forces an update from Yahoo, but only if the market is closed.\n", argv[0]);
    exit(EXIT_FAILURE);
  }
  if (argc >= 2) {
    // convert symbol parm to uppercase
    memset(Sym,0,sizeof(Sym));
    for (x=0;x<strlen(argv[1]);x++) Sym[x]=toupper(argv[1][x]);
    // verify symbol exists in stockinfo, else exit
    #include "Includes/beancounter-conn.inc"
    sprintf(query,"select symbol,active from stockinfo where symbol = \"%s\"",Sym);
    if (mysql_query(mysql,query)) print_error(mysql, "01 Failed to query database");
    result=mysql_store_result(mysql);
    if ((result==NULL) && (mysql_errno(mysql))) print_error(mysql, "store_results failed"); 
    num_rows = mysql_num_rows(result);
    if (num_rows == 0) {	// not a valid ticker symbol
      printf("%s not found \n",Sym);
      #include "Includes/mysql-disconn.inc"
      exit(EXIT_FAILURE);
    } else {
      row=mysql_fetch_row(result);
      if (!strcmp(row[1],"0")) {
	mysql_free_result(result);
	printf("%s not active\n",Sym);
	#include "Includes/mysql-disconn.inc"
	exit(EXIT_FAILURE);
      }
    }
  mysql_free_result(result);
  }
  if (argc == 3) {
    // is it a valid parm?
    if (strcmp(argv[2],"force")) {	// no, print message and exit
      printf("Usage:  %s Sym [force]\n", argv[0]);
      exit(EXIT_FAILURE);
    }
    // otherwise turn on the "force" flag to coerce invalid dates to this one
    force++;
  }	// end If argc==3
    
  // initialize the time structures with today
  t = t2 = time(NULL);
  TM2 = localtime(&t);
  TM = localtime(&t);
  if (TM == NULL) {
    perror("localtime");
    exit(EXIT_FAILURE);
  }
  strftime(qDate, sizeof(qDate), "%F", TM);
  // is this a business day?
  if (TM->tm_wday>0 && TM->tm_wday<6) {
    // yes, make sure it is 30 minutes past market close time on a business day
    if (TM->tm_hour<15 || (TM->tm_hour==15 && TM->tm_min<30)) {
	printf("No update for %s, market is still open today\n",Sym); 
	exit(EXIT_FAILURE);
    }
  }
  // back up a weekend to the previous Friday
  if (TM->tm_wday == 6) {
    t -= DAY_SECONDS; 
    TM = localtime(&t);
    strftime(qDate, sizeof(qDate), "%F", TM);	// save the adjusted date
  } else if (TM->tm_wday == 0) {
    t -= DAY_SECONDS * 2; 
    TM = localtime(&t);
    strftime(qDate, sizeof(qDate), "%F", TM);	// save the adjusted date
  } 
  // check for holidays
  sprintf(query,"select last_bus_day from Investments.holidays where holiday = \"%s\"",qDate);
  if (mysql_query(mysql,query)) print_error(mysql, "01 Failed to query database");
  result=mysql_store_result(mysql);
  if ((result==NULL) && (mysql_errno(mysql))) print_error(mysql, "store_results failed"); 
  num_rows = mysql_num_rows(result);
  if (num_rows == 1) {	// holiday today, use last business day date
    if ((row=mysql_fetch_row(result))==NULL) {
      printf("oops - count() failed\n");
      exit(EXIT_FAILURE);
    }
    strcpy(qDate,row[0]);	// point to last_bus_day
    strptime(qDate,"%F",TM);	// ensure t and TM are concurrent with qDate
    t = mktime(TM);
  }
  mysql_free_result(result);

  // use YahooQuote to get today's data, if  local time > 15:30    
  // get date,close,open,prev_close,volume,change,low-high
  chunk.memory = calloc(1,1);
  chunk.size = 0;
  curl_global_init(CURL_GLOBAL_NOTHING);
  curl=curl_easy_init();
  if(!curl) {
    fprintf(stderr,"curl init failed, aborting process\n");
    exit(EXIT_FAILURE);
  }    
  sprintf(qURL,"http://download.finance.yahoo.com/d/quotes.csv?s=%s&e=.csv&f=d1l1opvc1mxj1edra2w",Sym);
  chunk.size=0;
  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, ParseTicker);
  curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&chunk);
  curl_easy_setopt(curl, CURLOPT_URL, qURL);
  res=curl_easy_perform(curl);
  if (res) {	// error, no data retrieved
	printf("Error %d Unable to access the internet\n",res);
	printf("%s\n",errbuf);
	print_error(mysql,"curl error, no data retrieved");
  }
  // was any data returned?
  if (strstr(chunk.memory,"404 Not Found")) {     
    curl_easy_setopt(curl, CURLOPT_URL, qURL);
    printf("%s not found\n",Sym);
    curl_easy_cleanup(curl);
    free(chunk.memory);
    #include "Includes/mysql-disconn.inc"
    exit(EXIT_FAILURE);
  }

    // parse the supplied data
    memset(thisDate,0,sizeof(thisDate));
    saveptr = strtok(chunk.memory ,",");
    strcpy(thisDate,saveptr+1);	// formatted differently as mm/dd/yyyy
    if ((saveptr2=strchr(thisDate,'"'))) memset(saveptr2,32,1);
    // is it valid?
    if (!strcmp(thisDate,"\"N/A\"")) {	// bad symbol, deactivate it
      printf("Deactivated bad symbol %s\n",Sym);
      sprintf(query,"update stockinfo set active=false where symbol = \"%s\"",Sym);
      if (!DEBUG) mysql_query(mysql,query);
      curl_easy_cleanup(curl);
      free(chunk.memory);
      #include "Includes/mysql-disconn.inc"
      exit(EXIT_FAILURE);
    }

    // verify the retrieved date is valid, else force it to match qDate
    memset(TM2,0,sizeof(struct tm));
    // adjust the format to match ISO standard
    if (!strptime(thisDate,"%m/%d/%Y",TM2))  {
	strftime(thisDate,sizeof(thisDate),"%F",TM2);
	if (force) {
	  printf("Overriding pricing date to %s from %s for %s\n",qDate,thisDate,Sym);
	} else {	// bad date supplied, "force" not enabled, just quit now.
	  sprintf(query,"update stockinfo set active=false where symbol = \"%s\"",Sym);
	  if (!DEBUG) mysql_query(mysql,query);
	  printf("Deactivated bad symbol %s with invalid date\n",Sym);
	  curl_easy_cleanup(curl);
	  free(chunk.memory);
	  #include "Includes/mysql-disconn.inc"
	  exit(EXIT_FAILURE);
	}
    }
    if (strncmp(qDate,thisDate,10)) {
      // is the retrieved date in the future?
      TM2->tm_hour = 1;
      t2 = mktime(TM2);
      if (t2 > t) {	// future date?
	// yes, skip it unless "force" is enabled
	if (force) {
	  printf("Overriding pricing date to %s from %s for %s\n",qDate,thisDate,Sym);
	} else {	// bad date supplied, "force" not enabled, just quit now.
	  printf("Skipping %s on %s invalid future date %s\n",Sym,qDate,thisDate);
	  curl_easy_cleanup(curl);
	  free(chunk.memory);
	  #include "Includes/mysql-disconn.inc"
	  exit(EXIT_FAILURE);
	}
      } else if (t2 < (t-(7*DAY_SECONDS))) {
	// is it over a week in the past?
	  // yes, skip it
	  sprintf(query,"update stockinfo set active=false where symbol = \"%s\"",Sym);
	  if (!DEBUG) mysql_query(mysql,query);
	  printf("Deactivated symbol %s with old date %s\n",Sym,thisDate);
	  curl_easy_cleanup(curl);
	  free(chunk.memory);
	  #include "Includes/mysql-disconn.inc"
	  exit(EXIT_FAILURE);
      }
    }	// end If compare qDate,thisDate

    // start main processing
    // split out today's data
    saveptr=strtok(NULL,",");
    strcpy(day_close,saveptr);	// save day_close
    if (!strcmp(day_close,"0.00")) strcpy(day_close,"NULL");
    if (!strcmp(day_close,"N/A")) strcpy(day_close,"NULL");
    saveptr=strtok(NULL,",");
    strcpy(day_open,saveptr);	// save day_open
    if (!strcmp(day_open,"N/A")) strcpy(day_open,"NULL");
    saveptr=strtok(NULL,",");
    strcpy(prev_close,saveptr);	// save previous_close
    if (!strcmp(prev_close,"N/A")) strcpy(prev_close,"NULL");
    saveptr=strtok(NULL,",");
    strcpy(volume,saveptr);	// save volume
    if (!strcmp(volume,"N/A"))  strcpy(volume,"NULL");
    saveptr=strtok(NULL,",");
    strcpy(day_change,saveptr);	// save day_change
    if ((saveptr2=strchr(day_change,'+'))) memset(saveptr2,32,1);
    saveptr=strtok(NULL,"-");
    strcpy(day_low,saveptr+1);	// save day_low
    if ((saveptr2=strchr(day_low,'"'))) memset(saveptr2,32,1);
    if (strstr(day_low,"N/A"))  strcpy(day_low,"NULL");
    saveptr=strtok(NULL,",");
    strcpy(day_high,saveptr);	// save day_high
    if ((saveptr2=strchr(day_high,'"'))) memset(saveptr2,0,1);
    if (strstr(day_high,"N/A")) strcpy(day_high,"NULL");
    saveptr=strtok(NULL,",");
    strcpy(exchange,saveptr+1);	// save exchange
    if ((saveptr2=strchr(exchange,'"'))) memset(saveptr2,32,1);
    saveptr=strtok(NULL,",");
    strcpy(buf,saveptr);	// save capitalisation
    // convert capitalisation format to millions
      if ((saveptr2=strchr(buf,'B'))!=NULL) {	// convert Billions to Millions
	  memset(saveptr2,0,1);
	  sprintf(capitalisation,"%.4f",strtod(buf,NULL)*1000);
      } else if ((saveptr2=strchr(buf,'M'))!=NULL) {	// already in Millions
	  memset(saveptr2,0,1);
	  strcpy(capitalisation,buf);
      } else if ((saveptr2=strchr(buf,'T'))!=NULL) {	// convert Trillions to Millions
	  memset(saveptr2,0,1);
	  sprintf(capitalisation,"%.4f",strtod(buf,NULL)*1000000);
      } else if ((saveptr2=strchr(buf,'K'))!=NULL) {	// convert Thousands to Millions
	  memset(saveptr2,0,1);
	  sprintf(capitalisation,"%.4f",strtod(buf,NULL)*0.001);
      } else {	// just copy it over
	  strcpy(capitalisation,buf);
      }
    if (!strcmp(capitalisation,"N/A"))  strcpy(capitalisation,"NULL");
    saveptr=strtok(NULL,",");
    strcpy(earnings,saveptr);	// save earnings
    if (!strcmp(earnings,"N/A"))  strcpy(earnings,"NULL");
    saveptr=strtok(NULL,",");
    strcpy(dividend,saveptr);	// save dividend
    if (!strcmp(dividend,"N/A"))  strcpy(dividend,"NULL");
    saveptr=strtok(NULL,",");
    strcpy(p_e_ratio,saveptr);	// save p_e_ratio
    if (!strcmp(p_e_ratio,"N/A"))  strcpy(p_e_ratio,"NULL");
    saveptr=strtok(NULL,",");
    strcpy(avg_volume,saveptr);	// save avg_volume
    if (!strcmp(avg_volume,"N/A"))  strcpy(avg_volume,"NULL");
    saveptr=strtok(NULL,",");
    strcpy(low_52weeks,saveptr+1);	// save low_52weeks
    if (strstr(low_52weeks,"N/A"))  strcpy(low_52weeks,"NULL");
    if ((saveptr2=strchr(low_52weeks,'-'))) memset(saveptr2,0,1);
    strcpy(high_52weeks,saveptr2+1);	// save high_52weeks
    if ((saveptr2=strchr(high_52weeks,'"'))) memset(saveptr2,0,1);
    if (strstr(high_52weeks,"N/A"))  strcpy(high_52weeks,"NULL");

    // build the SQL string
    sprintf(query,"select symbol from stockprices where symbol = \"%s\" and date = \"%s\"",Sym,qDate);
    if (mysql_query(mysql,query)) { print_error(mysql, "02 Failed to query database");	}
    result=mysql_store_result(mysql);
    if (result==NULL) { print_error(mysql, "store_results failed"); } 
    // build and run the update or insert query
    if (mysql_num_rows(result)) 	// existing data, just update it
      sprintf(query,"update stockprices set day_open=%s,day_high=%s,day_low=%s,day_close=%s,volume=%s,day_change=%s,previous_close=%s \
      where symbol = \"%s\" and date = \"%s\"",day_open,day_high,day_low,day_close,volume,day_change,prev_close,Sym,qDate);
    else 	// new date, insert it
      sprintf(query,"insert into stockprices (symbol,date,day_open,day_high,day_low,day_close,volume,day_change,previous_close) \
      VALUES(\"%s\",\"%s\",%s,%s,%s,%s,%s,%s,%s)",Sym,qDate,day_open,day_high,day_low,day_close,volume,day_change,prev_close);
    mysql_free_result(result);
    // update the database
    if (!DEBUG) if (mysql_query(mysql,query))  print_error(mysql, "Failed to update stockprices for today");
    if (DEBUG) printf("%s\n",query);
    // update stockinfo
    sprintf(query,"update stockinfo set exchange=\"%s\",capitalisation=%s,low_52weeks=%s,high_52weeks=%s,earnings=%s,dividend=%s,p_e_ratio=%s,avg_volume=%s \
    where symbol = \"%s\"",exchange,capitalisation,low_52weeks,high_52weeks,earnings,dividend,p_e_ratio,avg_volume,Sym);
    if (!DEBUG)  if (mysql_query(mysql,query))  print_error(mysql, "Failed to update stockinfo");
    if (DEBUG) printf("%s\n",query);
      updated++;
  
  curl_easy_cleanup(curl);
  free(chunk.memory);
  // update the beancounter timestamp
  if (updated) mysql_query(mysql,"update beancounter set data_last_updated = NOW()");
  // finished with the database
  #include "Includes/mysql-disconn.inc"
  exit(EXIT_SUCCESS);
}
